// 谈起闭包
// 我将会从js的垃圾回收，作用域链，代码执行环境讲起
// 首先，产生闭包的条件是，函数嵌套，内部函数引用了外部函数的局部变量，这样导致了这个变量在内存上无法被回收，
// 由此产生了所谓的闭包
// 那么这个变量为什么无法被回收了呢，这就要从js的垃圾回收谈起，js代码在执行时，会进入执行环境
// 而垃圾回收会根据代码是处于进入环境还是退出环境状态，对于处于进入环境状态的代码，系统认为它可能马上被使用
// 是绝对不会去回收它的，所以它会一直在内存上，也就说，闭包是因为代码处于执行环境，所以不会被回收
// 可是为什么代码会在执行环境呢，外部函数代码明明已经结束了，它的变量应该被释放呀
// 这就跟作用域链有关了，内部函数使用变量时，现在当前环境查找，没有的话，会从包含环境内找
// 此时，它在外部的包含环境中找到了，所以它就拿过来用了，我们之前说的当代码进入执行环境时，是不会被回收的
// 而外部函数的变量,此时正在被使用(作用域链的原理),所以它处于执行环境,所以它是不会被回收的,也就保存在了内存上
// 以上就是闭包产生的原因了
// 也因此,闭包是一把双刃剑,它延长了变量的生命周期,但是它也会造成内存泄漏,因为一直不回收